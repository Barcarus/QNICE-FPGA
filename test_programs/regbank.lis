000001                    ; Checks, if all register banks are working by putting data in all registers
000002                    ; then generating a check sum for each register. The validity of the check sum
000003                    ; for each register is shown on the emulated TIL by cycling through all 8
000004                    ; result registers, showing the actual value, then subtracting the correct
000005                    ; value, so that next a "0" should be shown.
000006                    ;
000007                    ; Also, a simple RAM check is included, as this test program does subtractions
000008                    ; in RAM and furtheron uses RSUB to call the delay routine, therefore a super
000009                    ; small stack on RAM is utilized using two nested function calls
000010                    ;
000011                    ; Everything works correct, if the TIL displays the following sequence in
000012                    ; a loop: 8080, 0000, 1700, 0000
000013                    ;
000014                    ; done by sy2002 on August 2015
000015                    
000016                    IO$TIL_BASE     .EQU    0xFF10              ; Address of TIL-display
000017                    
000018                    ; about 10.000.000 cycles are needed to delay 1 sec
000019                    WAIT_CYCLES1    .EQU    0x1388              ; 0x1388 = decimal 5.000
000020                    WAIT_CYCLES2    .EQU    0x07D0              ; 0x07D0 = decimal 2.000
000021                    
000022                    NEXT_BANK       .EQU    0x0100              ; added to SR: switch to next bank
000023                    
000024                    ; expected check sum values
000025                    CHECK_R0        .EQU    0x8080              ; sum(1..256) = 32.896 = 0x8080
000026                    CHECK_R1        .EQU    0x1700              ; 256 x 23 = 5.888 = 0x1700
000027                    
000028                    ; memory locations
000029                    STACK_TOP       .EQU    0x8020              ; top of the stack, initial SP
000030                    VAR_DIFF        .EQU    0x8000              ; variable in RAM to store the
000031                                                                ; difference between a register
000032                                                                ; value and the expected value
000033                    
000034                                    .ORG    0x0000
000035                    
000036  0000  0FB4  8020                  MOVE    0x8020, R13         ; setup stack pointer
000037                    
000038  0002  AFB8  FF00                  OR      0xFF00, R14         ; activate highest register page
000039  0004  0FA0  0100                  MOVE    0x0100, R8          ; loop through 256 banks
000040  0006  0FA4  0001                  MOVE    0x0001, R9          ; we need to sub 1 often
000041  0008  0FA8  0100                  MOVE    NEXT_BANK, R10      ; we need to sub 0x100 often
000042  000A  0FAC  0017                  MOVE    23, R11             ; we need to move 23 often
000043                    
000044                    ; fill registers throughout 256 registerbanks with meaningful values
000045  000C  0800        BANK_LOOP       MOVE    R8, R0              ; move 256 downto 1 in all R0's
000046  000D  0B04                        MOVE    R11, R1             ; move 23 in all R1's
000047  000E  3A38                        SUB     R10, R14            ; previous register bank
000048  000F  3920                        SUB     R9, R8              ; decrease loop counter
000049  0010  FFAB  FFFA                  RBRA    BANK_LOOP, !Z       ; loop 256 downto 1 (0 exits)
000050                    
000051                    ; calculate check sums over all registers and store the results in bank 0
000052  0012  0FA0  00FF                  MOVE    0x00FF, R8          ; loop only through 255 as we
000053  0014  9FB8  00FF                  AND     0x00FF, R14         ; are adding everything to bank 0
000054                    
000055  0016  1A38        CHECK_LOOP      ADD     R10, R14            ; next bank
000056                    
000057  0017  0030                        MOVE    R0, R12             ; use R12 as temp for R0
000058  0018  0E2C                        MOVE    R14, R11            ; save current bank page
000059  0019  9FB8  00FF                  AND     0x00FF, R14         ; back to bank 0
000060  001B  1C00                        ADD     R12, R0             ; accumulate check sum in R0
000061  001C  0B38                        MOVE    R11, R14            ; restore current bank page
000062                    
000063  001D  0130                        MOVE    R1, R12             ; use R12 as temp for R1
000064  001E  0E2C                        MOVE    R14, R11            ; save current bank page
000065  001F  9FB8  00FF                  AND     0x00FF, R14         ; back to bank 0
000066  0021  1C04                        ADD     R12, R1             ; accumulate check sum in R1
000067  0022  0B38                        MOVE    R11, R14            ; restore current bank page
000068                    
000069  0023  3920                        SUB     R9, R8              ; decrease loop counter
000070  0024  FFAB  FFF0                  RBRA    CHECK_LOOP, !Z      ; loop 255 downto 1 (0 exits)
000071                    
000072                    
000073                    ; output results to TIL
000074  0026  9FB8  00FF                  AND     0x00FF, R14         ; switch back to reg bank 0
000075  0028  0FB0  FF10                  MOVE    IO$TIL_BASE, R12    ; TIL MMIO display address
000076                    
000077                                    ; display register R0 and the difference to the expected value
000078  002A  0020         DISPLAY_LOOP   MOVE    R0, R8              ; register = R8
000079  002B  0FA4  8080                  MOVE    CHECK_R0, R9        ; expected value = R9
000080  002D  FFB0  0008                  RSUB    DISPLAY_REG, 1      ; call sub routine
000081                    
000082                                    ; dito R1
000083  002F  0120                        MOVE    R1, R8
000084  0030  0FA4  1700                  MOVE    CHECK_R1, R9
000085  0032  FFB0  0003                  RSUB    DISPLAY_REG, 1
000086                    
000087  0034  FFA0  FFF4                  RBRA    DISPLAY_LOOP, 1
000088                    
000089  0036  E000                        HALT
000090                    
000091                    ; sub routine to display the register value and the expected value
000092                    ; the sub routine uses another sub routine so this is also a nice first
000093                    ; test of stacked sub routine calls
000094                    ; input: R8 = register, R9 = expected value, R12 = TIL BASE
000095  0037  1FB8  0100  DISPLAY_REG     ADD     NEXT_BANK, R14      ; next register bank
000096  0039  0831                        MOVE    R8, @R12            ; display value on TIL
000097  003A  FFB0  000A                  RSUB    DELAY, 1            ; wait 1 second
000098  003C  0F80  8000                  MOVE    VAR_DIFF, R0        ; memory location of variable
000099  003E  0801                        MOVE    R8, @R0             ; store register value in var
000100  003F  3901                        SUB     R9, @R0             ; subtract expected value
000101  0040  0071                        MOVE    @R0, @R12           ; display difference reg vs. expct
000102  0041  FFB0  0003                  RSUB    DELAY, 1            ; wait 1 second
000103  0043  3FB8  0100                  SUB     NEXT_BANK, R14      ; previous register bank
000104  0045  0DBC                        MOVE    @R13++, R15         ; return from sub routine
000105                    
000106                    ; sub routine to wait for about 1sec
000107  0046  1FB8  0100  DELAY           ADD     NEXT_BANK, R14      ; next register bank
000108  0048  0F84  07D0                  MOVE    WAIT_CYCLES2, R1    ; outer wait cycles (2.000)
000109  004A  0F80  1388  WAIT_LOOP2      MOVE    WAIT_CYCLES1, R0    ; inner wait cycles (5.000)
000110  004C  3F80  0001  WAIT_LOOP1      SUB     1, R0               ; dec inner wait cycles and ...
000111  004E  FFAB  FFFC                  RBRA    WAIT_LOOP1, !Z      ; ... repeat if not zero
000112  0050  3F84  0001                  SUB     1, R1               ; dec outer wait cycles and ...
000113  0052  FFAB  FFF6                  RBRA    WAIT_LOOP2, !Z      ; ... repeat if not zero
000114  0054  3FB8  0100                  SUB     NEXT_BANK, R14      ; previous register bank
000115  0056  0DBC                        MOVE    @R13++, R15         ; return from sub routine
000116                    


EQU-list:
--------------------------------------------------------------------------------------------------------
IO$TIL_BASE             : 0xFF10    WAIT_CYCLES1            : 0x1388    WAIT_CYCLES2            : 0x07D0    
NEXT_BANK               : 0x0100    CHECK_R0                : 0x8080    CHECK_R1                : 0x1700    
STACK_TOP               : 0x8020    VAR_DIFF                : 0x8000    

Label-list:
--------------------------------------------------------------------------------------------------------
BANK_LOOP               : 0x000C    CHECK_LOOP              : 0x0016    DISPLAY_LOOP            : 0x002A    
DISPLAY_REG             : 0x0037    DELAY                   : 0x0046    WAIT_LOOP2              : 0x004A    
WAIT_LOOP1              : 0x004C    
