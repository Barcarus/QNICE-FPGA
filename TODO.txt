HARDWARE:

* Research, if the asynchronous RAM (flip flops) for the register banks can
  be replaced by synchronous RAM (Block RAM) without increasing the amount
  of CPU cycles per instruction.

* Refactor MMIO for not having so many comperators: use only one register
  output and link it to all devices; use a smart subtraction to find out
  registers and drastically shorten the code.

* Remove ROM and replace by prefilled RAM

* Get rid of hardcoded clock speed dependencies:
  + Have a global constant that reflects the speed of the board and refactor
  all hardcoded frequencies to be dependend formulas from this speed
  (e.g. UART, SD card, VGA, debouncer, SD$TIMEOUT_HIGH, etc.)
  + Have a generator that generates the speeds that certain components need
  as input, e.g. the SD Card component needs currently hardcoded 25 MHz
  + Keyboard: remove hardcoded 18000 constant
  + Monitor: gets hardcoded 10000 clock cycles => 2.000 "nop" loops

* Improve design to support 100 MHz
  + EAE might need the busy flag then (currently the combinatorial net
    for div and mod takes about 30ns to execute, therefore it is buffered
    in the FF "res")

* PS/2: Refactor scancode conversion to be more table/ROM like and less
  like a huge array of multiplexers

* Refactor TIL and TIL Mask to support 8 digits / 32 bits

* Refactor Video RAM: avoid inferring two RAMs for video RAM

* VGA being able to report the vertical retrace for flicker-free graphics,
  e.g. for being able to enhance Q-TRIS to work double-buffered and to
  switch buffers during retrace. And/or for having a good general sync.
  mechanism. To "report" via register and/or interrupt.

* Memory management unit (more than 64kWords of RAM/ROM, pages, etc.)

* Interrupt system

* Debugging mechanisms (e.g. single-step mode in hardware)

MONITOR:

* Get rid of the hardcoded keyboard locale

* BS/DEL when entering hex digits (and at other reasonable places)

* Basic mounting (SD Card), browsing and file loading / file running support

ASSEMBLER STANDARD LIBs (WITHIN MONITOR):

* SD card support / FAT32 support

* finalize 32 bit arithmetic (muls32, divs32)

* String libraries: Switchable locales? UTF8 support?
  (Or - as an alternative to this fully fledged solution: Can we implement a
  workaround that kind of works most of the time? E.g. a translation mechanism
  that checks STDIN/STDOUT and acts accordingly, e.g.
  if STDIN=UART and BS is pressed, then assume UTF-8, but if STDIN=USB and
  BS is pressed, then assume 8859-15? And similar behaviour for
  non-ASCII chars like "Ã¤"? Mapping depending on STDIN/STDOUT combinations?
  And always storing single-byte characters? That would mean, that we e.g.
  translate some selected chars from UTF-8 to 8859-15 while entering them
  via STDIN=UART. More thoughts to be invested here.)

* Long term: Floating point support (in software? or in hardware? or only
  in the C lib and not at all on the monitor's level?)

NATIVE TOOLCHAIN: ASSEMBLER:

<currently no TODOs>

VBCC TOOLCHAIN: C COMPILER and/or C STANDARD LIB:

* Enhance the demo program mul32_div32.asm by adding cycle counting. Then
  measure the runtime: how fast are the built-in 32bit int functions? Then
  replace them by linking a version of the lib, that uses the monitor's
  32bit integer math functions instead. (mul32 should be way faster due
  to the fact that it uses EAE and div32 at least a bit as it is written
  in plain assembler)

* check/validate correct register bank usage

* correct startup.s (ABRA vs. ASUB)

* Optimization: Correct "costs", so that e.g. in -O3 constants are
  loaded in to registers in a loop instead of e.g doing SUB 1, @R1++

* use new gets routine

* add file system support (fopen, fclose, ...)

* EAE wait code as soon as necessary (currently no wait code, maybe this
  becomes necessary when we switch to 100 MHz)
